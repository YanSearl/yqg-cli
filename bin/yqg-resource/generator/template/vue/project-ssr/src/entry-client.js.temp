/**
 * @author <%= username %>
 * @email <%= email %>
 * @date <%= timeCreated %>
 * @desc generated by <%= signature %>
 */

import 'babel-polyfill';

import Vue from 'yqg-common/vue';
import {fetchComponentsAsyncData, reuseServerState, mixin as asyncDataMixin} from 'yqg-common/vue/ssr/async-data';
import {registerComponentsStoreModules, mixin as storeModuleMixin} from 'yqg-common/vue/ssr/store-module';
import {genClientMixin} from 'yqg-common/vue/ssr/title';

import {DEFAULT_TITLE} from './common/constant/config';
import {createApp} from './main';

Vue.mixin(asyncDataMixin);
Vue.mixin(storeModuleMixin);
Vue.mixin(genClientMixin({rootTitle: DEFAULT_TITLE}));
const {app, router, store} = createApp();

router.onReady(() => {
    const matchedComponents = router.getMatchedComponents();
    registerComponentsStoreModules(store, matchedComponents);
    reuseServerState(store);

    // Add router hook for handling asyncData.
    // Doing it after initial route is resolved so that we don't double-fetch the data that we already have.
    // Using router.beforeResolve() so that all async components are resolved.
    router.beforeResolve((to, from, next) => {
        const matched = router.getMatchedComponents(to);
        const prevMatched = router.getMatchedComponents(from);

        let diffed = false;
        const activated = matched.filter((component, idx) => diffed || (diffed = (prevMatched[idx] !== component)));
        registerComponentsStoreModules(store, activated);
        fetchComponentsAsyncData(store, to, activated).then(() => next()).catch(next);
    });

    app.$mount('#app');
});

if (module.hot) {
    module.hot.accept();
}
